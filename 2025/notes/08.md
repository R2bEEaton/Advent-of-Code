# Day 8 - Playground

> [<- Yesterday](07.md) | [Tomorrow ->](09.md)

Eh, not so good. Had some unfortunate slowdowns, but yet again it was a good puzzle, can't really complain! This just pretty well solidified TJ's lead, now at 11 points.

The puzzle is about linking pairs of nodes together and determining the length of connected sets.

|      | Part One | Part Two | Total |
|------|----------|----------|-------|
| Time | 45:43    | 7:22     | 53:05 |

## Part One

I closed Discord and didn't write any notes last night because I wanted to go to bed as soon as I was done. Unfortunately had some issues with Part One that made me take pretty long, and decently longer than a bunch of other people in the NJIT ACM leaderboard.

1. ~10 minutes on trying to make a one-liner to sort the pairs of Euclidian distances, for some reason
2. A while on code to look up which circuit each node was a part of in `O(1)` time rather than `O(n)`, where `n = number of circuits` time. This was fine and working, but spent too long on it and ended up scrapping it anyway and it turned out to not save too much time. My final solution (Part Two) runs in under 2 seconds. It could be faster with this though, I will grant myself that.
3. Figuring out why my circuits list was wrong. I didn't realize at first that I had to merge existing circuits, until I realized I had the 18th node in two different circuits. That's not right...
4. And finally, reading comprehention! I scrapped completely working code because I didn't read that I just needed to find the product of the lengths of the largest 3 sets. I was multiplying *all* unique circuit lengths! So I completely scrapped my working code and started over, got the same answer (albeit with much better code), then re-read the end of the problem... yay!

[Code](../code/08a.py)

```python
from collections import defaultdict
from helpers.datagetter import aocd_data_in
import math
import itertools
import functools

din, aocd_submit = aocd_data_in(split=True, numbers=True)

# Spent a while on this line for some reason
closest = sorted(itertools.combinations(range(len(din)), r=2), key=functools.cmp_to_key(lambda x, y: math.dist(din[x[0]], din[x[1]]) - math.dist(din[y[0]], din[y[1]])))

circuits = []

# Had some ugly code for this that I scrapped, using a seen dictionary to keep track of which points were in each circuit for O(1) lookups but I scrapped it.
# Unfortunately, my code was RIGHT and I was getting it wrong because I was multiplying the length of every circuit instead of just the top three!!!
# After recoding it much better this way and getting the same answer, I re-read the question and realized the issue with the top three.
for x in range(1000):
    a, b = closest[x]

    ac = None
    bc = None

    for i, c in enumerate(circuits):
        if a in c:
            ac = i
        if b in c:
            bc = i

    if ac is not None and bc is not None:
        if ac != bc:
            circuits[ac].update(circuits[bc])
            del circuits[bc]
    elif ac is not None:
        circuits[ac].add(b)
    elif bc is not None:
        circuits[bc].add(a)
    else:
        circuits.append(set([a, b]))

clen = sorted(len(x) for x in circuits)

ans = clen[-1] * clen[-2] * clen[-3]

aocd_submit(ans)
```

## Part Two
A relatively quick Part Two, simply needed to come up with the condition for my while loop then stop when the first (and necessarily only) circuit contains all nodes. Answer is the product of the X coordinates of the nodes we just connected.

[Code](../code/08b.py)

```python
from collections import defaultdict
from helpers.datagetter import aocd_data_in
import math
import itertools
import functools

din, aocd_submit = aocd_data_in(split=True, numbers=True)

closest = sorted(itertools.combinations(range(len(din)), r=2), key=functools.cmp_to_key(lambda x, y: math.dist(din[x[0]], din[x[1]]) - math.dist(din[y[0]], din[y[1]])))

circuits = []

x = 0

# Decently straightforward update.
while x == 0 or len(circuits[0]) != len(din):
    a, b = closest[x]

    ac = None
    bc = None

    for i, c in enumerate(circuits):
        if a in c:
            ac = i
        if b in c:
            bc = i

    if ac is not None and bc is not None:
        if ac != bc:
            circuits[ac].update(circuits[bc])
            del circuits[bc]
    elif ac is not None:
        circuits[ac].add(b)
    elif bc is not None:
        circuits[bc].add(a)
    else:
        circuits.append(set([a, b]))
    
    x += 1

ans = din[a][0] * din[b][0]

aocd_submit(ans)
```