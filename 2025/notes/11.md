# Day 11 - Reactor

> [<- Yesterday](10.md) | [Tomorrow ->](12.md)

A very cool problem! Unfortunately I slept through my alarm to wake up and do Advent of Code. Maybe it's because I've have no chance at #1 in the NJIT ACM Leaderboard for days, my body was like... sleep is more important. And that's fair, I've been going to bed late every day and waking up at 7 AM.

|             | Part One | Part Two | Total   |
|-------------|----------|----------|---------|
| Time        | 8:04:38  | 1:39:42  | 9:44:20 |
| Time (mine) | 4:38     | 1:39:42  | 1:44:20 |

## Part One
Super simple bruteforce with NetworkX. Love NetworkX.

[Code](../code/11a.py)

```python
from helpers.datagetter import aocd_data_in
import networkx

din, aocd_submit = aocd_data_in(split=True, numbers=False)

G = networkx.DiGraph()

for line in din:
    nodes = line.split(": ")
    for node in nodes[1].split(" "):
        G.add_edge(nodes[0], node)

all_paths = list(networkx.all_simple_paths(G, source="you", target="out"))

aocd_submit(len(all_paths))
```

## Part Two
Ok here's where it gets interesting. Unfortunately took pretty long though to get the knowledge and epiphanies required to solve it.

1. We don't care what the actual paths are, just how many there are
2. The problem describes a Directed Acyclical Graph
    1. Directed - from AoC: "can't flow backwards"
    2. Acyclical - by the very fact that the problem asks for the total paths, we can infer that there are no cycles
3. For any graph, a property exists such that the number of paths from `u -> v` = the sum of the number of paths from `w -> v` for all `w` which are direct children of `u`
4. For DAGs, the prior property can be used for Dynamic Programming because:
    1. DAGs guarantee finite number of paths
    2. Topological sort gives us a processing order where all descendants are computed before their ancestors
    3. As such, each subproblem can be memoized

During the process I first determined using NetworkX functions that (in my input at least) a path `dac -> ... -> fft` doesn't exist. So I knew my solution would have to look like `svr -> fft -> dac -> out`. Also important to realize is that we need to know each of the number of paths between these pairs, since the solution needs to include both `fft` and `dac`. So we can use another property of graphs.

> `nPaths(u -> v)` including `w` = `nPaths(u -> w) * nPaths(w -> v)`

So if we compute the number of paths between each pair, and find the product, that's our answer! After the fact, I also realized that for all paths that must include two nodes:

> `nPaths(u -> v)` including `w` and `x` = `(nPaths(u -> w) * nPaths(w, x) * nPaths(x, v)) + (nPaths(u -> x) * nPaths(x, w) * nPaths(w, v))`

Basically, check all permutations of visiting required nodes and sum them up! I added this to my solution for completeness, in case some inputs have situations when paths exist in all cases.

<details>
<summary>
Here's my original code, but I realized doing both a topological sort and memoized DFS is redundant. Since it's a DAG, doing recursive DFS necessarily follows topological order. You can also see my process of figuring this out by some of the comments I started writing immediately after submitting the correct answer.
</summary>

```python
from helpers.datagetter import aocd_data_in
import networkx

din, aocd_submit = aocd_data_in(split=True, numbers=False)

G = networkx.DiGraph()

for line in din:
    nodes = line.split(": ")
    for node in nodes[1].split(" "):
        G.add_edge(nodes[0], node)

# No paths from dac to out include fft

# all_paths = list(networkx.all_simple_paths(G, source="dac", target="out"))
# print(len(all_paths))
# print(sum([1 if "fft" in path else 0 for path in all_paths]))

def dfs(start, end, paths):
    # I need to run DFS to count the number of paths, and then use DP keeping in mind # of paths from u -> v = u -> w * w -> v
    # If I do reverse topological order then w -> v will already be calculated.
    if start in paths:
        return paths[start]

    if start == end:
        return 1
    
    ans = 0
    for adj in G.neighbors(start):
        # print(adj)
        inter = dfs(adj, end, paths)
        paths[adj] = inter
        ans += inter
    return ans

topo = list(networkx.topological_sort(G))

def getPaths(start, end):
    paths = dict() # Interestingly, it looks like this can even be moved inside the for loop below, for only a modest runtime increase
    # It definitely needs to be reset for each path count calculation though because the problem is unique between different start and end nodes.
    # Topological sort + DP based DFS (where we are NOT enumerating each path!) is the solution, and the position of the cache clear otherwise doesn't seem to matter much.
    # Wait a minute... DFS is necessarily already topologically sorted...
    for i in range(topo.index(end), -1, -1):
        node = topo[i]
        
        inter = dfs(node, end, paths)
        if node == start:
            return inter
    return 0
        

ans = (getPaths("svr", "fft") * getPaths("fft", "dac") * getPaths("dac", "out")) \
    + (getPaths("svr", "dac") * getPaths("dac", "fft") * getPaths("fft", "out"))

aocd_submit(ans)
```
</details>

Somehow this was most helpful reference I found, even though it's super vague. Happy I was able to figure out what the answerer was talking about.
[StackOverflow: Number of paths between two nodes in a DAG](https://stackoverflow.com/questions/5164719/number-of-paths-between-two-nodes-in-a-dag/5164820#5164820). Confusion from reading this response is what lead me to do both DFS and Topological Sort at the same time lol.

Also, I actually had working code for a little while and didn't submit the final answer because I thought I'd already tried it. I kept going over my code and testing it on constructed inputs and it kept coming up right! So I tried the number I was getting and it did indeed work. Nice. Honestly, had a lot of fun.

This code is much better formatted, and removes the redundancy, utilizing topological sort to eliminating the need for recursion and saving probably hundreds of microseconds!

[Code](../code/11b.py)

```python
from collections import defaultdict
from helpers.datagetter import aocd_data_in
import networkx

din, aocd_submit = aocd_data_in(split=True, numbers=False)

G = networkx.DiGraph()
for line in din:
    nodes = line.split(": ")
    for node in nodes[1].split(" "):
        G.add_edge(nodes[0], node)

topo = list(networkx.topological_sort(G))


def getPaths(start, end):
    paths = defaultdict(int)
    paths[end] = 1
   
    for i in range(topo.index(end) - 1, -1, -1):
        node = topo[i]
        
        for adj in G.neighbors(node):
            paths[node] += paths[adj]

        if node == start:
            return paths[node]
    return 0
        

ans = (getPaths("svr", "fft") * getPaths("fft", "dac") * getPaths("dac", "out")) \
    + (getPaths("svr", "dac") * getPaths("dac", "fft") * getPaths("fft", "out"))
aocd_submit(ans)
```