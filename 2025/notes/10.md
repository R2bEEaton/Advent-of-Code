# Day 10 - Factory

> [<- Yesterday](09.md) | [Tomorrow ->](11.md)

I fell asleep and woke up randomly at 0:35. Erm, for the record, please subtract 35 minutes from my time!

|             | Part One | Part Two | Total   |
|-------------|----------|----------|---------|
| Time        | 1:10:11  | 37:44    | 1:47:55 |
| Time (mine) | 35:11    | 37:44    | 1:12:55 |

## Part One
I originally used recursion, but I quickly realized that would get stuck because it would take the path of pressing the same button over and over and the only constraint we had was checking if the goal was met, and it's probably not going to happen pressing the same button over and over.

So I switched to using a Priority Queue to sort by number of presses so far, and simply returned as soon as I found that the current matched the goal. I was originally working with tuples but the code was taking a lot of time and memory, especially on a couple specific machines, so I did two optimizations:

1. Switch to bitwise operations for toggling lights. Probably should have started this way. Avoids unncessary `tuple -> list -> tuple` conversions I was doing.
2. Add a set of seen states. If we've seen the state before (regardless of how many button presses we had seen it out), we don't need to do these same button presses to it again, because it's already been done and its children added to the priority queue (maybe even in a previous generation of button presses, too!). This saved the most time, and made it run in a milliseconds.

The run that actually solve the problem didn't have optimization #2 and ended up taking like 30GB of memory lol.

[Code](../code/10a.py)

```python
import heapq
from helpers.datagetter import aocd_data_in
import tqdm

din, aocd_submit = aocd_data_in(split=True, numbers=False)

ans = 0

def getFewest(curr, goal, buttons):
    pq = []

    # Originally ran without the seen set, but added it right after and saw a massive speedup so I kept it thinking I'd need it in Part Two
    seen = set()
    heapq.heappush(pq, (0, curr))
    
    while True:
        presses, curr = heapq.heappop(pq)
        if curr not in seen:
            seen.add(curr)
        else:
            continue
        for seq in buttons:
            # Was originally using tuples, but switched to bitwise operations for speed
            new_curr = curr ^ seq
            if new_curr == goal:
                return presses + 1
            heapq.heappush(pq, (presses + 1, new_curr))


for line in tqdm.tqdm(din):
    # What is with me and unnecessarily complicated one liners this year??
    goal, buttons = tuple([0 if x == "." else 1 for x in line.split(" ")[0][1:-1]]), [[int(y) for y in x[1:-1].split(",")] for x in line.split(" ")[1:-1]]
    # print("Goal", sum([(2 ** i) * x for i, x in enumerate(goal)]))
    # print([sum([(2 ** y) * 1 for y in x]) for x in buttons])
    ans += getFewest(0, sum([(2 ** i) * x for i, x in enumerate(goal)]), [sum([(2 ** y) * 1 for y in x]) for x in buttons])

aocd_submit(ans)
```

## Part Two
Happy with this one! I started work on an updated function to find the minimum presses in much the same way, and came up with this which, to be fair, works!

```python
def getFewest(curr, goal, buttons):
    pq = []

    seen = set()

    heapq.heappush(pq, (0, curr))
    
    while True:
        presses, curr = heapq.heappop(pq)
        if curr not in seen:
            seen.add(curr)
        else:
            continue
        for seq in buttons:
            new_curr = tuple([curr[i] + 1 if i in seq else curr[i] for i in range(len(curr))])
            if new_curr == goal:
                return presses + 1
            if any([new_curr[i] > goal[i] for i in range(len(curr))]):
                continue
            heapq.heappush(pq, (presses + 1, new_curr))
```

Problem is, it'd probably never finish.

I realized the solution was probably math related (go figure) and started doing some searching online for Python SAT solvers, optimization capabilities of SymPy, etc. and stumbled across the [Scipy submodule called `optimize`](https://docs.scipy.org/doc/scipy/reference/optimize.html#). Then I found [`scipy.optimize.minimize`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog), with the headline "Linear programming: minimize a linear objective function subject to linear equality and inequality constraints." Sounds good to me!

Then I spent a while coercing the data into a problem that could be solved in the form required by the optimizer, which I originally did by hardcoding the values until something worked and then figured out how to generate it based on the machine line inputs. It was originally daunting but a surprising number of the inputs to this function are optional. 

The first time I ran the code on the real input, I got a number with a decimal place as the solution, and my heart sank, but after a quick Google search "linprog constrain to integer solutions" I found the integrality array, which I set to all 1's to force all parameters in the x vector to be integers.

[Code](../code/10b.py)

```python
from helpers.datagetter import aocd_data_in
import tqdm
import numpy as np
from scipy.optimize import linprog

din, aocd_submit = aocd_data_in(split=True, numbers=False)

ans = 0


def getFewestSolver(goal, buttons):
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html

    arrs = []
    for button in buttons:
        arr = [0] * len(goal)
        for b in button:
            arr[b] = 1
        arrs.append(arr)

    C = np.array(arrs)
    c = np.ones(C.shape[0])

    A_eq = C.T
    b_eq = np.array(goal)

    result = linprog(c, A_eq=A_eq, b_eq=b_eq, integrality=np.ones(C.shape[0]))

    return result.fun


for line in tqdm.tqdm(din):
    goal, buttons = tuple([int(x) for x in line.split(" ")[-1][1:-1].split(",")]), [[int(y) for y in x[1:-1].split(",")] for x in line.split(" ")[1:-1]]
    # print(goal, buttons)
    ans += getFewestSolver(goal, buttons)

aocd_submit(ans)
```