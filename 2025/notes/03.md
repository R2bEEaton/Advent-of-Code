# Day 3 - Lobby
                
> [<- Yesterday](02.md) | [Tomorrow ->](04.md)
                
An excellent puzzle resulting in a lot of time spent, but pretty cool! The first part was easy enough to bruteforce that I had my head down the wrong track for part two! Excellent puzzle design, and something I truly need to get into my head. If it's easy in Part One, it's probably not the solution for Part Two.

|      | Part One | Part Two | Total |
|------|----------|----------|-------|
| Time | 2:02     | 42:16    | 44:18 |

## Part One
Very simple bruteforce to find and sum for each line the max number created from all pairs of in-order, not necessarily next to each other, numbers in that line.

[Code](../code/03a.py)

```python
from helpers.datagetter import aocd_data_in

din, aocd_submit = aocd_data_in(split=True, numbers=False)

ans = 0

for line in din:
    highest = 0
    for x in range(len(line)):
        for y in range(x + 1, len(line)):
            highest = max(highest, int(line[x] + line[y]))
    ans += highest

aocd_submit(ans)
```

## Part Two
For a while, I went down a Dynamic Programming rabbit hole, which I have later seen in the NJIT ACM chat wasn't a rabbit hole. I must have been doing something wrong, but I don't have my code to check it with. I created buckets to hold the largest number found of each length, and skipped checking numbers that would necessarily be smaller than those, for each length.

The solution I ended up on after a while, was discovered by doing some examples by hand, as is sometimes a helpful excercise. I figured that if I was trying to build the largest number possible, it should probably begin with the largest digit from the left, to give me the best chance at picking up some more large digits as I go. For a moment I thought, *well, wouldn't sometimes skipping a high digit be necessary in case some smaller number to the right might prove to be more helpful...* but then I realized that's dumb because the highest order digit contributes a literal order of magnitude more than the next digit, so should always be prioritized. Then I considered the case of smaller digits followed by, and ending with, a single 9. Since the number has to be 12 digits, I obviously cannot start with the 9 at the end because then I wouldn't have any more digits to build a 12 digit number with, left to right without mixing the order of the digits.

So, the algorithm took shape. Until you have built a string of 12 digits, scan from the left all the way up to the point when there are just enough numbers remaining to be able to complete the 12 digit number, and find the largest digit in that range. Get the index of its first occurrence, then add the digit to your number. Then repeat, except this time start scanning from the index to the right of the number you just picked, and with the right bound now being one smaller than it was before.

Very nice. Very long time though :cry: :sleepy:

[Code](../code/03b.py)

```python
from helpers.datagetter import aocd_data_in

din, aocd_submit = aocd_data_in(split=True, numbers=False)

ans = 0

for line in din:
    curr = ""
    start = 0
    line_list = list(map(int, list(line)))
    while len(curr) != 12:
        search = line_list[start : len(line) - (12 - len(curr)) + 1]
        idx = line_list.index(max(search), start)
        curr += line[idx]
        start = idx + 1
    ans += int(curr)

aocd_submit(ans)
```