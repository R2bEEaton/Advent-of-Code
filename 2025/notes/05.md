# Day 5 - Cafeteria

> [<- Yesterday](04.md) | [Tomorrow ->](06.md)

A nice puzzle, feels very reminiscent of [2023 Day 5](https://github.com/R2bEEaton/Advent-of-Code/blob/main/2023/notes/5.md) or [2022 Day 4](https://github.com/R2bEEaton/Advent-of-Code/blob/main/2022/4.md), but this time with big numbers. I like my solution for Part Two, and I had it a lot quicker but made a typo.

|      | Part One | Part Two | Total |
|------|----------|----------|-------|
| Time | 3:05     | 17:49    | 20:54 |

## Part One
Simple as for each ingredient ID, check if it exists in any range by comparing it with the beginning and end of the range.

[Code](../code/05a.py)

```python
from helpers.datagetter import aocd_data_in

din, aocd_submit = aocd_data_in(split=True, numbers=True)

ans = 0

ranges = []
init = True

for line in din:
    if line == []:
        init = False
        continue
    if init:
        ranges.append(list(map(abs, line)))
    else:
        for r in ranges:
            if line[0] >= r[0] and line[0] <= r[1]:
                ans += 1
                break

aocd_submit(ans)
```

## Part Two
Again, I like this solution mostly because it uses sets, sorts the pairs to avoid duplicate cases (unlike my code for 2023 Day 5), and is super quick. It adds each range to a set, and continuously loops over all combinations of range pairs, sorts them ascending, and looks for overlaps. The only two types of possible overlaps are therefore:

$` a_0 <= b_0 <= a_1 <= b_2 `$, where `A` and `B` overlap and $` a_0, b_1 `$ is a simplified range (remove `A`, and `B`, replace with simplified range).

$` a_0 <= b_0 <= b_1 <= a_1 `$, where `A` contains `B` and $` a_0, a_1 `$ is a simplified range (remove `B`).

Had to break out Paint.NET for that one. Keep simplifying range pairs until no overlaps are detected, and then sum the length of each range. Pretty cool!

The **typo** I made was accidentally removing range `A` in the second case, when it should have been `B`. I was scratching my head for a while on that one... I feel like I had everything by the 12-13 minute mark but I can't be sure.

[Code](../code/05b.py)

```python
from helpers.datagetter import aocd_data_in
import itertools

din, aocd_submit = aocd_data_in(split=True, numbers=True)

ans = 0

ranges = set()

for line in din:
    if line == []:
        break
    ranges.add(tuple(map(abs, line)))

overlap = True
while overlap:
    overlap = False
    for pair in itertools.combinations(ranges, r=2):
        a, b = sorted(pair)
        # A and B overlap
        if b[0] <= a[1] and b[1] >= a[1]:
            ranges.remove(a)
            ranges.remove(b)
            ranges.add((a[0], b[1]))
            overlap = True
            break
        # B is contained in A
        if a[0] <= b[0] and a[1] >= b[1]:
            ranges.remove(b)
            overlap = True
            break

for r in ranges:
    ans += r[1] - r[0] + 1

aocd_submit(ans)
```

## Part Three - Rayna's Solution

I told my wife the problem (because I love telling her about the problems and somehow she doesn't get bored listening to me ramble) and in 30 seconds she came up with a solution that beats mine by ~300x in run-time. And it's more elegant. And took her infinitely faster than I did to come up with mine.

Rayna's Note:

> The thought process of this solution was to visualize the ranges as pairs of parentheses, and then split and sort them in ascending order. Then I thought that comparing all the numbers would slow down the process so I instead focus on the parentheses and only look at the numbers when the parentheses balance out. So then I know the start and end of the new ranges (or mega-ranges, as I call them).

To augment this explanation a little, the cool part is that if you are keeping track of levels of parentheses, she waits until the parentheses are back at level 0. To visualize the example from the puzzle description:

```
Range Edges:        (3  5)  (10 14) (16 20) (12 18)
Range Edges Sorted: (3  5)  (10 (12 14) (16 18) 20)
Parentheses Level:  1    0  1   2     1 2     1   0
New Range Edges:    L....R  L...x.....x.x.....x...R
```

She's a genius!

[Code](../code/05c.py)

```python
from helpers.datagetter import aocd_data_in

din, aocd_submit = aocd_data_in(split=True, numbers=True)

ans = 0

ranges = set()

for line in din:
    if line == []:
        break
    ranges.add(tuple(map(abs, line)))

parens = []

ranges = sorted(ranges)

for x in ranges:
    l, r = x
    parens.append((l, '('))
    parens.append((r, ')'))

new_ranges = set()

l = 0
c = 0
for x, p in sorted(parens):
    if p == '(' and c == 0:
        l = x

    if p == '(':
        c += 1
    else:
        c -= 1
    
    if c == 0:
        new_ranges.add((l, x))

for r in new_ranges:
    ans += r[1] - r[0] + 1

aocd_submit(ans)
```